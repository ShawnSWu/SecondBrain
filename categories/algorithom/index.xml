<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithom on Shawn Wu</title><link>https://shawnswu.github.io/secondbrain/categories/algorithom/</link><description>Recent content in Algorithom on Shawn Wu</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 06 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://shawnswu.github.io/secondbrain/categories/algorithom/index.xml" rel="self" type="application/rss+xml"/><item><title>Raft Algorithom</title><link>https://shawnswu.github.io/secondbrain/p/raft-algorithom/</link><pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate><guid>https://shawnswu.github.io/secondbrain/p/raft-algorithom/</guid><description>&lt;img src="https://shawnswu.github.io/secondbrain/p/raft-algorithom/images/cover.jpeg" alt="Featured image of post Raft Algorithom" />&lt;p>不同於Paxos，Raft使用Leader(領導者)、Follower(追隨者)等更直觀的術語
並且簡化了複雜的流程，主要還是有三個流程&lt;/p>
&lt;ol>
&lt;li>&lt;span style="color: #E6CC93; font-size: 22px;">
&lt;b>Leader Election&lt;/b>
&lt;/span>&lt;/li>
&lt;li>&lt;span style="color: #E6CC93; font-size: 22px;">
&lt;b>Log Replication&lt;/b>
&lt;/span>&lt;/li>
&lt;li>&lt;span style="color: #E6CC93; font-size: 22px;">
&lt;b>Log Re&lt;/b>
&lt;/span>&lt;/li>
&lt;/ol>
&lt;p>在Raft中，有以下三個角色代表不同節點
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_01.png" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;h2 id="1-leader-election">1. Leader Election
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 20px;">
&lt;b>初始化狀態&lt;/b>
&lt;/span>&lt;/strong>： - 系統中的所有節點開始時都處於Follower狀態。
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_02.png" width="400" height="300">
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 20px;">
&lt;b>超時觸發選舉&lt;/b>
&lt;/span>&lt;/strong>： - 每個Follower節點在一定時間內沒有收到來自Leader的心跳訊號(Heartbeat)，它會轉變為Candidate並發起選舉，
以下舉例為節點初始化時的狀態(沒任何Leader 傳 heaerbeat)，每個節點的進度條則代表沒收到心跳訊號的時間
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_03.gif" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 20px;">
&lt;b>發送投票請求&lt;/b>
&lt;/span>&lt;/strong>： - Candidate節點向其他所有節點發送RequestVote請求，並附帶其當前的日誌索引和任期號。
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_04.gif" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 19px;">
&lt;b>接受投票&lt;/b>
&lt;/span>&lt;/strong>： - 其他節點（Followers）收到RequestVote請求後，會根據Candidate的日誌索引和任期號決定是否投票&lt;br>
如果該Candidate的日誌比自己更新，且尚未投票給其他Candidate，則會投票給該Candidate。&lt;/p>
&lt;blockquote>
&lt;span style="color: #88dba3; font-size: 20px;">
&lt;b>這裡是Raft算法的核心之一，透過網路時間差來投票選出Leader，像上面gif顯示的結尾部分，Candidate變成Leader&lt;/b>
&lt;/span>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 20px;">
&lt;b>當選為Leader&lt;/b>
&lt;/span>&lt;/strong>： - Candidate節點如果獲得多數節點的投票（超過半數），則成為Leader。
當選後，它會立即向其他節點發送心跳訊號，通知其成為新的Leader，以下為正常Leader持續傳送心跳訊號的樣子
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_05.gif" width="400" height="300">
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 20px;">
&lt;b>處理失敗情況&lt;/b>
&lt;/span>&lt;/strong>： - 如果Candidate在一定時間內沒有獲得足夠的投票，它會重新進入Follower狀態，並等待下一次選舉超時再次發起選舉。&lt;/p>
&lt;p>以下是當Leader掛掉 不再傳送心跳訊號時時，各節點會再重新選出新Leader的選舉機制（意義上就是回到 &lt;strong>1.初始化狀態&lt;/strong> 開始) &lt;br>
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_06.gif" width="400" height="300">
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;span style="color: #EF9C66; font-size: 18px;">
&lt;b>以下影片為多節點觸發投票機制的情況&lt;/b>
&lt;/span>
&lt;/blockquote>
&lt;div class="video-wrapper">
&lt;video
controls
src="images/Raft_07.mp4"
autoplay
>
&lt;p>
Your browser doesn't support HTML5 video. Here is a
&lt;a href="images/Raft_07.mp4">link to the video&lt;/a> instead.
&lt;/p>
&lt;/video>
&lt;/div>
&lt;h2 id="2-log-replication-日誌複製">2. Log Replication 日誌複製
&lt;/h2>&lt;blockquote>
&lt;span style="color: #EF9C66; font-size: 18px;">
&lt;b>當有了領導者之後，一旦系統有發生改變時，我們就需要將系統的所有變更複製到所有節點&lt;/b>
&lt;/span>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 20px;">
&lt;b>日誌條目追加&lt;/b>
&lt;/span>&lt;/strong>：
當 Leader 接收到一個新的數據變更請求(例如,增加一筆資料),它會將該變更記錄為一個新的日誌條目,並將其追加到其本地日誌中。&lt;/p>
&lt;p>以下例子 (綠色節點=Client) 是Client 傳一筆資料 = 5 的資料給 Leader&lt;br>
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_08.gif" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 20px;">
&lt;b>發送 AppendEntries 請求&lt;/b>
&lt;/span>&lt;/strong>：
Leader 會並行地將新的日誌條目發送給所有 Follower 節點,通過發送 AppendEntries RPC 請求。每個 Follower 在收到 AppendEntries 請求後,會將新的日誌條目附加到其本地日誌中
&lt;figure>&lt;img src="Raft_09.gif" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 20px;">
&lt;b>回覆成功或失敗&lt;/b>
&lt;/span>&lt;/strong>：
Follower 處理完 AppendEntries 請求後,會向 Leader 回覆是否成功附加了新的日誌條目。
&lt;figure>&lt;img src="Raft_10.gif" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;p>如果大多數(&amp;gt;50%)Follower 成功複製了日誌條目，則該條目被認為已經被認同了，並將回應傳送給Client端，狀態為已提交(Committed)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 20px;">
&lt;b>應用日誌條目&lt;/b>
&lt;/span>&lt;/strong>：
一旦某個日誌條目被提交,Leader 會通知所有 Follower 應用該條目到狀態機器(State Machine)中。這樣,所有節點的數據狀態就保持一致。
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_11.gif" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;span style="color: #E6CC93; font-size: 20px;">
&lt;b>處理網絡分區&lt;/b>
&lt;/span>&lt;/strong>：
Raft 甚至可以在網路分區時保持一致性
如果在日誌複製過程中出現網絡分區,導致 Leader 無法與部分 Follower 通信,則 Leader 會無限期等待這些 Follower 重新上線。一旦重新建立連接,Leader 會自動將它們的日誌複製過來。&lt;/p>
&lt;p>讓我們新增一個分割區來將 A 和 B 與 C、D 和 E 分開例子：
由於我們的分裂，我們現在有兩位不同任期的Leader
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_12.gif" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;p>我們新增另一個客戶端並嘗試更新兩個Leader的資料
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_13.png" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;blockquote>
&lt;p>各分區開始各做各的&lt;/p>
&lt;/blockquote>
&lt;p>圖中下面的一個Client端將嘗試將節點 B 的值設為『3』，但由於節點 B 因為節點數量不夠多而無法使選舉機制成功，所以無法複製資料到多數節點，因此其日誌條目一直保持未提交狀態&lt;br>
(專注看下面的分區)
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_14.gif" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;p>再來看上面的Client端分區
Client 將嘗試將節點E的值設為“8”，因為結點多到可以使選舉機制成功，所以其他Follwer也會更新&lt;/p>
&lt;p>(專注看上面的分區)
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_15.gif" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;blockquote>
&lt;p>當我們修復網路分割區時&lt;/p>
&lt;/blockquote>
&lt;p>節點 B 將會看到更新的『選舉任期』，所以無條件接受別人的資料版本，並接受新領導者的日誌，接著，我們的日誌在整個叢集中就變成是一致的了。
&lt;figure>&lt;img src="https://shawnswu.github.io/secondbrain/secondbrain/p/raft-algorithom/images/Raft_16.gif" width="600" height="500">
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>通過以上過程,Raft 確保了在任何時候,大多數節點的日誌都是完全一致的。這樣就保證了系統的數據一致性和容錯性。&lt;/p></description></item></channel></rss>